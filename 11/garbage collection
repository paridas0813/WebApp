unity 的内存分为栈内存和堆内存。栈内存超出作用域会立即释放回收。堆内存不会被立即释放回收，需要在特殊条件下才执行回收。当内存不足时候执行堆垃圾回收，因此
它的执行与我们需要的内存相关，由于垃圾回收会遍历堆上的所有的物体，找到没有被引用的才标记为删除，由于这个过程比较消耗时间因此会对性能造成一定的影响。
 垃圾回收产生的问题 1 回收消耗0的时间长 2 回收的时间有可能不合适 3 产出内存碎片
 解决方法 1.缓存 2.少产生对象 3oject pool
 
 通常引起不必要的垃圾回收的情况 
 string 
 Unity function calls   GameObject.CompareTag isn’t unique; many Unity function calls have alternative versions that cause no heap allocations. For example, we could use Input.GetTouch() and Input.touchCount in place of Input.touches, or Physics.SphereCastNonAlloc() in place of Physics.SphereCastAll().
 Boxing 
 Coroutines
 foreach loops
 Function references  Anonymous methods and method references should be minimized in performance-sensitive code, and especially in code that executes on a per-frame basis.
LINQ and Regular Expressions

Structuring our code to minimize the impact of garbage collection

Manually forcing garbage collection
